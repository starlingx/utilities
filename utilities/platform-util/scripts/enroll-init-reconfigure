#!/bin/bash
#
# Copyright (c) 2024-2025 Wind River Systems, Inc.
#
# SPDX-License-Identifier: Apache-2.0
#
# Utility to reconfigure OAM and update sysadmin password
# by first ensuring sys-inv and mtc services are active
# and ready to accept the password change.
#

function check_rc_die {
    local -i rc=${1}
    msg=${2}
    if [ ${rc} -ne 0 ]; then
        log_fatal "${msg} [rc=${rc}]"
    fi
}

function log_fatal {
    echo "$(tput setaf 1)$(date "+%F %H:%M:%S") FATAL: ${*}$(tput sgr0)" >&2
    send_ipmi_event "$EVENT_PLATFORM_CLOUDINIT_UPDATE_FAILED"
    exit 1
}

function log_warn {
    echo "$(tput setaf 3)$(date "+%F %H:%M:%S"): WARN: ${*}$(tput sgr0)" >&2
}

function log_info {
    echo "$(date "+%F %H:%M:%S"): INFO: $*" >&2
}

function usage {
    cat <<ENDUSAGE
Utility to reconfigure OAM and update sysadmin password.

Usage:
   $(basename "$0") --oam_subnet <oam_subnet>
                    --oam_gateway_ip <oam_gateway_ip>
                    --oam_ip <oam_ip>
                    --new_password <new_password>

        --oam_subnet <subnet>: Specify OAM subnet
        --oam_gateway_ip <ip>: Specify OAM gateway IP
        --oam_ip <ip>: Specify OAM IP (the floating IP for duplex system)
        --oam_c0_ip <ip>: Specify Controller-0 OAM IP (required for duplex systems)
        --oam_c1_ip <ip>: Specify Controller-1 OAM IP (required for duplex systems)
        --new_password <password>: Specify new password for sysadmin user
ENDUSAGE
}

# IPMI event types
readonly EVENT_FACTORY_SETUP_COMPLETE="factory_setup_complete"
readonly EVENT_FACTORY_SETUP_FAILED="factory_setup_failed"

readonly EVENT_APISERVER_CERT_OK="apiserver_cert_ok"
readonly EVENT_RENEW_FAIL_KUBECTL="renew_fail_kubectl"
readonly EVENT_RENEW_FAIL_PODS="renew_fail_pods"
readonly EVENT_LEAF_CERTS_RENEW_FAIL="leaf_certs_renew_fail"
readonly EVENT_CERTMANAGER_CERTS_FAIL="certmanager_certs_fail"

readonly EVENT_MANUAL_CAS_OK="k8s_frontproxy_etcd_certs_ok"
readonly EVENT_MANUAL_CA_K8S_FP_FAIL="k8s_frontproxy_certs_fail"
readonly EVENT_MANUAL_CA_ETCD_FAIL="etcd_cert_fail"
readonly EVENT_MANUAL_CAS_BOTH_FAIL="k8s_frontproxy_etcd_certs_fail"

readonly EVENT_SLOCAL_CA_OK="slocal_ca_cert_ok"
readonly EVENT_SLOCAL_CA_FAIL="slocal_ca_cert_fail"

readonly EVENT_PLATFORM_CLOUDINIT_UPDATE_COMPLETE="platform_cloudinit_update_complete"
readonly EVENT_PLATFORM_CLOUDINIT_UPDATE_FAILED="platform_cloudinit_update_failed"

# IPMI payloads (data bytes)
readonly DATA_FACTORY_SETUP_COMPLETE="0x04 0x12 0xCC 0x63 0xCC 0x10 0xE0 # \"Factory Setup Complete\""
readonly DATA_FACTORY_SETUP_FAILED="0x04 0x12 0xCC 0x63 0xCC 0x10 0xE1 # \"Factory Setup Failed\""

readonly DATA_APISERVER_CERT_OK="0x04 0x12 0xCC 0x63 0xCC 0x10 0xE2 # \"ApiServer Cert Valid\""
readonly DATA_LEAF_CERTS_RENEW_FAIL="0x04 0x12 0xCC 0x63 0xCC 0x10 0xE3 # \"K8S Leaf Certs Renew Failed\""
readonly DATA_RENEW_FAIL_PODS="0x04 0x12 0xCC 0x63 0xCC 0x10 0xE4 # \"Pods Cert Renew Failed\""
readonly DATA_CERTMANAGER_CERTS_FAIL="0x04 0x12 0xCC 0x63 0xCC 0x10 0xE5 # \"Cert-manager Secrets Renew Failed\""
readonly DATA_RENEW_FAIL_KUBECTL="0x04 0x12 0xCC 0x63 0xCC 0x10 0xE6 # \"Kubectl Cert Renew Failed\""

readonly DATA_MANUAL_CAS_OK="0x04 0x12 0xCC 0x63 0xCC 0x10 0xE7 # \"Manual CA Certs Valid\""
readonly DATA_MANUAL_CA_K8S_FP_FAIL="0x04 0x12 0xCC 0x63 0xCC 0x10 0xE8 # \"K8S/Front-proxy Cert Expired\""
readonly DATA_MANUAL_CA_ETCD_FAIL="0x04 0x12 0xCC 0x63 0xCC 0x10 0xE9 # \"ETCD CA Cert Expired\""
readonly DATA_MANUAL_CAS_BOTH_FAIL="0x04 0x12 0xCC 0x63 0xCC 0x10 0xEA # \"ETCD CA and K8S/Front-proxy Certs Expired\""

readonly DATA_SLOCAL_CA_OK="0x04 0x12 0xCC 0x63 0xCC 0x10 0xEB # \"System-local-ca Cert Valid\""
readonly DATA_SLOCAL_CA_FAIL="0x04 0x12 0xCC 0x63 0xCC 0x10 0xEC # \"System-local-ca Cert Expired\""

readonly DATA_PLATFORM_CLOUDINIT_UPDATE_COMPLETE="0x04 0x12 0xCC 0x63 0xCC 0x10 0xED # \"Platform Cloud-init Update Complete\""
readonly DATA_PLATFORM_CLOUDINIT_UPDATE_FAILED="0x04 0x12 0xCC 0x63 0xCC 0x10 0xEE # \"Platform Cloud-init Update Failed\""

# IPMI SEL event format reference:
#   [EvM Revision] [Sensor Type] [Sensor Number] [Event Dir / Event Type Code]
#                  [Event Data 1] [Event Data 2] [Event Data 3]
#
# Example: 0x04 0x12 0xCC 0x63 0xCC 0x10 0xE0
#   0x04 = EvM Revision (IPMI v2.0)
#   0x12 = Sensor Type (vendor-defined / OEM-specific)
#   0xCC = Sensor Number (firmware-defined)
#   0x63 = Event direction (vendor-specific encoding)
#   0xCC 0x10 0xE0 = Event Data bytes (3 bytes, OEM-specific payload)
#
# For our usage:
# - The third byte (Sensor Number) is set to 0x01, corresponding to a sensor type "Unknown".
# - The last three bytes are the Event Data payload, used to encode success/failure/status.
#
# These values are read by enroll_init.yml playbook running on the System Controller,
# triggered during subcloud enrollment. Any changes to these bytes require updating both
# this definition and the playbook that interprets them.

function send_ipmi_event {
    local event_type="$1"
    local event_data

    case "$event_type" in
        "$EVENT_FACTORY_SETUP_COMPLETE")            event_data="$DATA_FACTORY_SETUP_COMPLETE" ;;
        "$EVENT_FACTORY_SETUP_FAILED")              event_data="$DATA_FACTORY_SETUP_FAILED" ;;

        "$EVENT_APISERVER_CERT_OK")                 event_data="$DATA_APISERVER_CERT_OK" ;;
        "$EVENT_RENEW_FAIL_KUBECTL")                event_data="$DATA_RENEW_FAIL_KUBECTL" ;;
        "$EVENT_RENEW_FAIL_PODS")                   event_data="$DATA_RENEW_FAIL_PODS" ;;
        "$EVENT_LEAF_CERTS_RENEW_FAIL")             event_data="$DATA_LEAF_CERTS_RENEW_FAIL" ;;
        "$EVENT_CERTMANAGER_CERTS_FAIL")            event_data="$DATA_CERTMANAGER_CERTS_FAIL" ;;

        "$EVENT_MANUAL_CAS_OK")                     event_data="$DATA_MANUAL_CAS_OK" ;;
        "$EVENT_MANUAL_CA_K8S_FP_FAIL")             event_data="$DATA_MANUAL_CA_K8S_FP_FAIL" ;;
        "$EVENT_MANUAL_CA_ETCD_FAIL")               event_data="$DATA_MANUAL_CA_ETCD_FAIL" ;;
        "$EVENT_MANUAL_CAS_BOTH_FAIL")              event_data="$DATA_MANUAL_CAS_BOTH_FAIL" ;;

        "$EVENT_SLOCAL_CA_OK")                      event_data="$DATA_SLOCAL_CA_OK" ;;
        "$EVENT_SLOCAL_CA_FAIL")                    event_data="$DATA_SLOCAL_CA_FAIL" ;;

        "$EVENT_PLATFORM_CLOUDINIT_UPDATE_COMPLETE") event_data="$DATA_PLATFORM_CLOUDINIT_UPDATE_COMPLETE" ;;
        "$EVENT_PLATFORM_CLOUDINIT_UPDATE_FAILED")   event_data="$DATA_PLATFORM_CLOUDINIT_UPDATE_FAILED" ;;
        *)
            log_warn "Unknown IPMI event type: $event_type"
            return 1
            ;;
    esac

    local temp_file=$(mktemp /tmp/ipmi_event_XXXXXX.txt)
    echo "$event_data" > "$temp_file"

    if ipmitool sel add "$temp_file" 2>/dev/null; then
        log_info "IPMI event sent successfully: $event_type"
        rm -f "$temp_file"
        return 0
    else
        log_warn "Failed to send IPMI event: $event_type"
        rm -f "$temp_file"
        return 1
    fi
}

# The enroll-init reconfigure script runs during startup via cloud-init while
# system services may not be settled. This timing can lead to intermittent errors
# for early system commands. This function is used to mitigate these problems by
# retrying commands as needed.
function execute_with_retries {
    local command="$1"
    local retries=0
    local max_retries=10

    # TODO(srana): Consider checking a flag/service for
    # some of the commands executed using this function
    while [ $retries -lt $max_retries ]; do
        if $command; then
            return 0
        fi
        log_warn "Failed $command. Retrying in 30s ..."
        retries=$((retries + 1))
        sleep 30
    done

    return 1
}

function check_services_status {
    log_info "Checking services status..."
    max_retries=10
    retries=0

    while [ $retries -lt $max_retries ]; do
        sm_output=$(sm-dump)

        sysinv_status=$(echo "$sm_output" | awk '/sysinv-inv/ {print $2}')
        mtc_status=$(echo "$sm_output" | awk '/mtc-agent/ {print $2}')

        if [ "$sysinv_status" == "enabled-active" ] && [ "$mtc_status" == "enabled-active" ]; then
            log_info "Required services are now enabled-active."
            return 0
        else
            log_warn "Required services are not yet enabled-active. Retrying... "
        fi

        retries=$((retries + 1))
        sleep 30
    done

    log_fatal "Required services are not enabled-active after $max_retries attempts."
}

function load_credentials {
    log_info "Loading credentials..."

    if [ ! -f /etc/platform/openrc ]; then
        log_fatal "/etc/platform/openrc does not exist."
    fi

    if ! execute_with_retries "source /etc/platform/openrc"; then
        log_fatal "Failed to load credentials after multiple attempts."
    fi

    log_info "Credentials loaded successfully."
}

# Ensure OAM reconfiguration is required by comparing the current system
# OAM configuration values to the input reconfiguration values. This helps
# avoid unnecessary calls to system oam-modify, which could cause issues
# in later enrollment steps. For example, a timing issue has been observed
# because the OAM IP is already available, service endpoint IPs are configured,
# but rerunning the Puppet manifest interferes with enrollment.
function check_reconfigure_OAM {
    system_mode=$(awk -F= '/system_mode/ {print $2}' /etc/platform/platform.conf)

    log_info "Checking if OAM reconfiguration is necessary..."

    if ! execute_with_retries "system oam-show"; then
        log_fatal "system oam-show failed after multiple attempts."
    fi

    oam_show_output=$(system oam-show)

    check_rc_die $? "system oam-show failed"

    reconfig_required=false

    if [ "$system_mode" = "duplex" ]; then
        # DX: Current system oam values
        oam_c0_ip=$(echo "$oam_show_output" | awk '/oam_c0_ip/ {print $4}')
        oam_c1_ip=$(echo "$oam_show_output" | awk '/oam_c1_ip/ {print $4}')
        oam_floating_ip=$(echo "$oam_show_output" | awk '/oam_floating_ip/ {print $4}')
        oam_gateway_ip=$(echo "$oam_show_output" | awk '/oam_gateway_ip/ {print $4}')
        oam_subnet=$(echo "$oam_show_output" | awk '/oam_subnet/ {print $4}')

        log_info "C0 IP: current - $oam_c0_ip, reconfig - $OAM_C0_IP
                  C1 IP: current - $oam_c1_ip, reconfig - $OAM_C1_IP
                  Floating IP: current - $oam_floating_ip, reconfig - $OAM_IP
                  Gateway IP: current - $oam_gateway_ip, reconfig - $OAM_GATEWAY_IP
                  Subnet: current - $oam_subnet, reconfig - $OAM_SUBNET"

        # Compare the current settings with the input values
        if [ "$oam_c0_ip" != "$OAM_C0_IP" ] || [ "$oam_c1_ip" != "$OAM_C1_IP" ] || \
           [ "$oam_floating_ip" != "$OAM_IP" ] || [ "$oam_gateway_ip" != "$OAM_GATEWAY_IP" ] || \
           [ "$oam_subnet" != "$OAM_SUBNET" ]; then
            reconfig_required=true
        fi
    else
        # SX: Current system oam values
        oam_ip=$(echo "$oam_show_output" | awk '/oam_ip/ {print $4}')
        oam_gateway_ip=$(echo "$oam_show_output" | awk '/oam_gateway_ip/ {print $4}')
        oam_subnet=$(echo "$oam_show_output" | awk '/oam_subnet/ {print $4}')

        log_info "IP: current - $oam_ip, reconfig - $OAM_IP
                  Gateway IP: current - $oam_gateway_ip, reconfig - $OAM_GATEWAY_IP
                  Subnet: current - $oam_subnet, reconfig - $OAM_SUBNET"

        # Compare the current settings with the input values
        if [ "$oam_ip" != "$OAM_IP" ] || [ "$oam_gateway_ip" != "$OAM_GATEWAY_IP" ] || \
           [ "$oam_subnet" != "$OAM_SUBNET" ]; then
            reconfig_required=true
        fi
    fi

    if [ "$reconfig_required" = true ]; then
        log_info "OAM reconfiguration is required."
        return 0
    else
        log_info "OAM reconfiguration is not required."
        return 1
    fi
}

function is_ipv6 {
    local addr=$1
    # simple check for ':'
    if [ "${addr/:/}" != "${addr}" ]; then
        # addr is ipv6
        return 0
    fi
    return 1
}

#
# display network info
#
function display_network_info {
    local contents
    contents=$(
        {
            echo
            echo "************ Links/addresses ************"
            /usr/sbin/ip addr show
            echo "************ IPv4 routes ****************"
            /usr/sbin/ip route show
            echo "************ IPv6 routes ****************"
            /usr/sbin/ip -6 route show
            echo "*****************************************"
        }
    )
    log_info "Network info:${contents}"
}


function reconfigure_OAM {
    system_mode=$(awk -F= '/system_mode/ {print $2}' /etc/platform/platform.conf)

    args="oam_subnet=$OAM_SUBNET oam_gateway_ip=$OAM_GATEWAY_IP"

    if [ "$system_mode" = "duplex" ]; then
        if [ -z "$OAM_C0_IP" ] || [ -z "$OAM_C1_IP" ]; then
            log_fatal "Missing required arguments. Please specify both --oam_c0_ip and --oam_c1_ip"
        fi

        args="$args oam_floating_ip=$OAM_IP oam_c0_ip=$OAM_C0_IP oam_c1_ip=$OAM_C1_IP"
    else
        args="$args oam_ip=$OAM_IP"
    fi

    log_info "Reconfiguring OAM: $args ..."

    if ! execute_with_retries "system oam-modify $args"; then
        log_fatal "system oam-modify failed after multiple attempts."
    fi
}

function reconfigure_password {
    log_info "Reconfiguring sysadmin password..."
    echo "sysadmin:$NEW_PASSWORD" | sudo chpasswd -e
    check_rc_die $? "chpasswd failed"
}


APISERVER_CERT="/etc/kubernetes/pki/apiserver.crt"
KUBECONFIG="/etc/kubernetes/admin.conf"
RETRY_COUNT=10
RETRY_SLEEP=15
NAMESPACES=("cert-manager" "flux-helm" "kube-system")
NODE_FILTER="controller-0"

check_apiserver_cert() {
    log_info "Checking apiserver certificate (${APISERVER_CERT}), threshold=${CERT_CHECKEND_DAYS} days..."
    if _cert_valid_for_threshold "${APISERVER_CERT}"; then
        log_info "OK: apiserver certificate valid for >= ${CERT_CHECKEND_DAYS} days."
        return 0
    fi
    log_warn "apiserver cert expired or expiring in < ${CERT_CHECKEND_DAYS} days."
    return 1
}

run_kube_cert_rotation() {
    if [ -x /usr/bin/kube-cert-rotation.sh ]; then
        log_info "Running /usr/bin/kube-cert-rotation.sh..."
        bash -x /usr/bin/kube-cert-rotation.sh
    else
        log_info "/usr/bin/kube-cert-rotation.sh not present; skipping."
    fi
}

recover_kubelet_cert() {
    log_info "Recovering kubelet client certificate..."
    WORKDIR="/home/sysadmin/kubelet"
    mkdir -p "$WORKDIR"
    cd "$WORKDIR" || return 1

    cat <<'EOF' > controller-0_csr.conf
[req]
prompt = no
x509_extensions = v3_req
distinguished_name = dn
[dn]
O = system:nodes
CN = system:node:controller-0
[v3_req]
basicConstraints = critical, CA:FALSE
keyUsage = critical, Digital Signature, Key Encipherment
extendedKeyUsage = TLS Web Client Authentication
EOF

    openssl genrsa -out controller-0.key 2048
    openssl req -new -key controller-0.key -out controller-0.csr -config controller-0_csr.conf
    openssl x509 -req -in controller-0.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out controller-0.crt -days 365 -extensions v3_req -extfile controller-0_csr.conf
    cat controller-0.key controller-0.crt > kubelet-client-cert_with_key.pem
    cp kubelet-client-cert_with_key.pem /var/lib/kubelet/pki
    cd /var/lib/kubelet/pki/ || return 1
    rm -f kubelet-client-current.pem
    ln -s /var/lib/kubelet/pki/kubelet-client-cert_with_key.pem kubelet-client-current.pem
    kill -s SIGHUP $(pidof kube-apiserver) || true
    kill -s SIGHUP $(pidof kube-scheduler) || true
    kill -s SIGHUP $(pidof kube-controller-manager) || true
    systemctl restart kubelet
    sm-restart-safe service sysinv-conductor || true
    sm-restart-safe service cert-mon || true
    cd /
    rm -rf "$WORKDIR"
}

wait_for_kubectl() {
    log_info "Waiting for kubectl to respond (retries=${RETRY_COUNT}, sleep=${RETRY_SLEEP}s)..."
    local i=0
    while [ $i -lt $RETRY_COUNT ]; do
        if kubectl --kubeconfig "${KUBECONFIG}" get nodes >/dev/null 2>&1; then
            log_info "kubectl responded."
            return 0
        fi
        sleep "${RETRY_SLEEP}"
        i=$((i+1))
    done
    return 1
}

delete_pods_on_node() {
    for ns in "${NAMESPACES[@]}"; do
        log_info "Deleting pods in '${ns}' on '${NODE_FILTER}'..."
        pods=$(kubectl --kubeconfig "${KUBECONFIG}" -n "${ns}" get po -o wide 2>/dev/null | awk -v n="${NODE_FILTER}" 'NR>1 && $0 ~ n {print $1}')
        if [ -n "${pods}" ]; then
            echo "${pods}" | xargs -r kubectl --kubeconfig "${KUBECONFIG}" -n "${ns}" delete po
        else
            log_info "No pods to delete in ${ns}."
        fi
    done
}

wait_pods_running_on_node() {
    log_info "Waiting for pods to be Running on '${NODE_FILTER}' (retries=${RETRY_COUNT}, sleep=${RETRY_SLEEP}s)..."
    local i=0
    while [ $i -lt $RETRY_COUNT ]; do
        local all_ok=1
        for ns in "${NAMESPACES[@]}"; do
            mapfile -t lines < <(kubectl --kubeconfig "${KUBECONFIG}" -n "${ns}" get po -o wide 2>/dev/null | awk -v n="${NODE_FILTER}" 'NR>1 && $0 ~ n {print $1, $3}')
            [ "${#lines[@]}" -eq 0 ] && continue
            for l in "${lines[@]}"; do
                state=$(echo "$l" | awk '{print $2}')
                if [ "$state" != "Running" ]; then all_ok=0; break; fi
            done
            [ $all_ok -eq 1 ] || break
        done
        [ $all_ok -eq 1 ] && { log_info "All target pods Running."; return 0; }
        sleep "${RETRY_SLEEP}"
        i=$((i+1))
    done
    return 1
}

# This checks etcd CA, Kubernetes Root CA, and Front Proxy CA expiration dates.
function check_manual_ca_certs {
    log_info "Checking manual CA certificates (threshold=${CERT_CHECKEND_DAYS} days)..."

    local CERTS=(
        "etcd:/etc/etcd/ca.crt"
        "k8s_root:/etc/kubernetes/pki/ca.crt"
        "front_proxy:/etc/kubernetes/pki/front-proxy-ca.crt"
    )

    local fail_etcd=false
    local fail_k8s_fp=false

    for entry in "${CERTS[@]}"; do
        IFS=: read -r name path <<<"$entry"
        if _cert_valid_for_threshold "$path"; then
            log_info "Valid: ${name} CA (${path})"
        else
            log_warn "Missing/expired/expiring (<${CERT_CHECKEND_DAYS}d): ${name} CA (${path})"
            if [ "$name" = "etcd" ]; then
                fail_etcd=true
            else
                fail_k8s_fp=true
            fi
        fi
    done

    if $fail_etcd && $fail_k8s_fp; then
        send_ipmi_event "$EVENT_MANUAL_CAS_BOTH_FAIL"
        log_fatal "Manual CA certs failed: both ETCD and Kubernetes/Front-Proxy"
    elif $fail_etcd; then
        send_ipmi_event "$EVENT_MANUAL_CA_ETCD_FAIL"
        log_fatal "Manual CA certs failed: ETCD"
    elif $fail_k8s_fp; then
        send_ipmi_event "$EVENT_MANUAL_CA_K8S_FP_FAIL"
        log_fatal "Manual CA certs failed: Kubernetes/Front-Proxy"
    else
        send_ipmi_event "$EVENT_MANUAL_CAS_OK"
        log_info "All manual CA certificates are valid"
    fi
}

# Check system-local-ca from Kubernetes secret (tls.crt)
function check_system_local_ca_cert {
    log_info "Checking system-local-ca, threshold=${CERT_CHECKEND_DAYS} days..."

    local crt_file
    crt_file="$(mktemp)"
    trap 'rm -f "${crt_file}"' RETURN

    # Attempt to read the secret; fail immediately if not found
    if ! kubectl --kubeconfig /etc/kubernetes/admin.conf -n "${SLOCAL_NS}" \
        get secret "${SLOCAL_SECRET}" -o 'jsonpath={.data.tls\.crt}' \
        | base64 -d > "${crt_file}" 2>/dev/null; then
        send_ipmi_event "$EVENT_SLOCAL_CA_FAIL"
        log_fatal "system-local-ca secret not found or unreadable: ${SLOCAL_NS}/${SLOCAL_SECRET}"
    fi

    if ! _cert_valid_for_threshold "${crt_file}"; then
        send_ipmi_event "$EVENT_SLOCAL_CA_FAIL"
        log_fatal "system-local-ca expired or expiring in < ${CERT_CHECKEND_DAYS} days."
    fi

    send_ipmi_event "$EVENT_SLOCAL_CA_OK"
    log_info "OK: system-local-ca (${SLOCAL_NS}/${SLOCAL_SECRET})"
}

# Certificates managed by cert-manager
RESTAPI_CERT="/etc/ssl/private/server-cert.pem"        # ssl (restapi/gui)
REGISTRY_CERT="/etc/ssl/private/registry-cert.crt"     # docker_registry

# Returns 0 if cert file exists and is valid >= CERT_CHECKEND_SECONDS
_cert_valid_for_threshold() {
    local f="$1"
    [ -r "$f" ] && openssl x509 -in "$f" -noout -checkend "$CERT_CHECKEND_SECONDS" >/dev/null 2>&1
}

# Wait up to ~5 minutes for both RESTAPI and REGISTRY certs to be valid
# for at least CERT_CHECKEND_SECONDS. Returns 0 on success, 1 on timeout.
check_cert_manager_renewal() {
    log_info "Waiting for cert-manager to refresh restapi/registry certs..."
    local attempts=20 sleep_s=15 i=0
    local restapi_done=false registry_done=false

    while [ $i -lt $attempts ]; do
        # Check RESTAPI only if not already validated
        if ! $restapi_done; then
            if _cert_valid_for_threshold "$RESTAPI_CERT"; then
                restapi_done=true
                log_info "RESTAPI cert renewed: $RESTAPI_CERT"
            else
                log_warn "RESTAPI cert not yet renewed: $RESTAPI_CERT"
            fi
        fi

        # Check REGISTRY only if not already validated
        if ! $registry_done; then
            if _cert_valid_for_threshold "$REGISTRY_CERT"; then
                registry_done=true
                log_info "REGISTRY cert renewed: $REGISTRY_CERT"
            else
                log_warn "REGISTRY cert not yet renewed: $REGISTRY_CERT"
            fi
        fi

        # If both are renewed, return successfully
        if $restapi_done && $registry_done; then
            return 0
        fi

        i=$((i+1))
        sleep "$sleep_s"
    done

    # Timeout: report which ones are still pending
    $restapi_done || log_warn "Timeout: RESTAPI cert never reached threshold."
    $registry_done || log_warn "Timeout: REGISTRY cert never reached threshold."
    return 1
}


# Declare required variables
OAM_SUBNET=""
OAM_GATEWAY_IP=""
OAM_IP=""
OAM_C0_IP=""
OAM_C1_IP=""
NEW_PASSWORD=""
CERT_CHECKEND_DAYS=3   # fail if cert expires in less than 3 days
CERT_CHECKEND_SECONDS=$((CERT_CHECKEND_DAYS*24*3600))
SLOCAL_NS="cert-manager"
SLOCAL_SECRET="system-local-ca"

log_info "Starting enroll-init reconfiguration..."

# Parse command line arguments
while [[ "$#" -gt 0 ]]; do
    case $1 in
        --help)
            usage
            exit 0
            ;;
        --oam_subnet)
            OAM_SUBNET="$2"
            shift 2
            ;;
        --oam_gateway_ip)
            OAM_GATEWAY_IP="$2"
            shift 2
            ;;
        --oam_ip)
            OAM_IP="$2"
            shift 2
            ;;
        --oam_c0_ip)
            OAM_C0_IP="$2"
            shift 2
            ;;
        --oam_c1_ip)
            OAM_C1_IP="$2"
            shift 2
            ;;
        --new_password)
            NEW_PASSWORD="$2"
            shift 2
            ;;
        *)
            log_fatal "Unexpected option: $1"
            ;;
    esac
done

# Main execution flow

# Ensure all required arguments are provided
if [ -z "$OAM_SUBNET" ] || [ -z "$OAM_GATEWAY_IP" ] || [ -z "$OAM_IP" ] || [ -z "$NEW_PASSWORD" ]; then
    usage
    log_fatal "Missing required arguments"
fi

check_manual_ca_certs

if check_apiserver_cert; then
    send_ipmi_event "$EVENT_APISERVER_CERT_OK"
else
    log_warn "apiserver cert expired/near-expiration; starting recovery..."
    run_kube_cert_rotation
    recover_kubelet_cert

    if ! wait_for_kubectl; then
        send_ipmi_event "$EVENT_RENEW_FAIL_KUBECTL"
        log_fatal "kubectl did not recover after retries."
    fi

    delete_pods_on_node

    if ! wait_pods_running_on_node; then
        send_ipmi_event "$EVENT_RENEW_FAIL_PODS"
        log_fatal "Pods did not reach Running state after retries."
    fi
    if ! check_apiserver_cert; then
        send_ipmi_event "$EVENT_LEAF_CERTS_RENEW_FAIL"
        log_fatal "An error occurred when renewing the leaf certificates"
    fi
    if check_cert_manager_renewal; then
        send_ipmi_event "$EVENT_APISERVER_CERT_OK"
    else
        send_ipmi_event "$EVENT_CERTMANAGER_CERTS_FAIL"
        log_fatal "REST API or Docker registry certs did not renew within timeout."
    fi
    log_info "Leaf certificate recovery complete and healthy."
fi

check_system_local_ca_cert

load_credentials
check_services_status

# Creating non-persistent flag, which will not survive on reboot.
# This flag will be used by apply_network_config.sh, to restate cloud-init configured route over
# puppet generated OAM route. This is necessary in case of vlan/interface reconfigured, as this is
# done only by cloud-init, and puppet generated ifcfg file does not know about this until reboot.
touch /var/run/.enroll-init-reconfigure

if check_reconfigure_OAM; then
    # Check directly on ifcfg file, to figure out the label/alias, which works for both IPv4 and IPv6 addresses:
    current_oam_if_name_with_label=$(grep net:oam /etc/network/interfaces.d/ifcfg-* | grep -oP '(?<=interfaces.d/ifcfg-).*?(?=:stx-description )')
    log_info "Current OAM IF label (alias):$current_oam_if_name_with_label."
    reconfigure_OAM
else
    # In cases where OAM reconfiguration is not required, the file 50-cloud-init
    # should already be removed at this stage, since the OAM configuration puppet
    # will not be executed and, consequently, neither will apply_network_config.
    log_info "OAM reconfiguration not required. Removing 50-cloud-init file."
    rm -f /etc/network/interfaces.d/50-cloud-init
fi

reconfigure_password

touch /var/lib/factory-install/state/enroll-init

send_ipmi_event "$EVENT_PLATFORM_CLOUDINIT_UPDATE_COMPLETE"
log_info "Successfully completed reconfiguration for enrollment."
